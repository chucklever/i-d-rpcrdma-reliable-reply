<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [ ]>

<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="1"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>

<rfc
  category="exp"
  docName="DOCNAMEVAR">

<front>

<title abbrev="RPC-Over-RDMA Reliable Reply">
Improving the Performance and Reliability of RPC Replies on RPC-over-RDMA Transports
</title>

<?rfc include="authors/author-lever-chuck.xml"?>

<date />

<area>Transport</area>
<workgroup>Network File System Version 4</workgroup>
<keyword>NFS-Over-RDMA</keyword>

<abstract>

<t>
RPC transports such as RPC-over-RDMA Version One
require reply buffers to be in place before an RPC Call is sent.
However, Upper Layer Protocols can have difficulty estimating
the expected maximum size of RPC replies in some cases.
This introduces the risk that an RPC Reply message
can overrun available reply resources,
preventing delivery of the message.
This document describes a mechanism that eliminates
the need for pre-allocation of reply resources for
unpredictably large replies.
</t>

</abstract>

<note title="Requirements Language">

<t>
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in <xref target="RFC2119"/>.
</t>

</note>

</front>

<middle>

<section
 title="Introduction"
 anchor="sec:introduction">

<t>
One way in which RPC transports such as RPC-over-RDMA Version One
improve efficiency is by ensuring reply resources for RPCs are
available in advance <xref target="I-D.ietf-nfsv4-rfc5666bis"/>.
These resources are provisioned before a requester sends
each RPC Call message.
They are provided to the responder to use for transmiting
the subsequent RPC Reply message back to the requester.
In particular, when an RPC Reply message is expected to be large,
the requester allocates and registers a Reply chunk.
</t>
<t>
However, there are rare occasions when the Upper Layer Protocol
is not able to estimate a reply size upper bound.
An example of this is the NFS version 4.2 READ_PLUS operation
<xref target="RFC7862"/> <xref target="I-D.ietf-nfsv4-rfc5667bis"/>.
</t>
<t>
In most cases, Upper Layer Protocols are capable of supplying
estimates of the maximum size of RPC Reply messages.
And, the average size of RPC Reply messages is small,
making the risk of Reply chunk overrun exceptionally small
for known Upper Layer Protocols.
</t>
<t>
Since the average size of actual RPC Replies is small,
requesters frequently allocate and register a Reply chunk
for a reply that, once it has been constructed by the responder,
is small enough to be sent inline.
A responder is free to use either the Reply chunk or
send the reply inline in this case,
but the requester's cost of preparing the Reply chunk has been wasted.
</t>
<t>
A better method of handling RPC replies could ensure
that RPC Replies can be received even when the maximum
possible size of some replies cannot be calculated in advance.
This method could also ensure that
no extra memory registration/invalidation operations
are necessary to make this guarantee.
This document resurrects the responder-provided Read chunk
capability outlined in <xref target="RFC5666"/> to achieve
these goals.
</t>

</section>

<section title="Background">

<t>
RPC-over-RDMA Version One uses an RDMA Send request to transmit
Transport headers and small RPC messages.
</t>
<t>
Each peer on an RPC-over-RDMA transport connection provisions
Receive buffers in which to capture incoming RDMA Send messages.
There is a limited number of these buffers, necessitating
accounting in the transport protocol to prevent
a peer from emitting more Send operations
than the receiver is prepared for.
</t>
<t>
The smallest buffer in this pool determines the largest
size message that can be recieved.
The size of the largest message that can be received via RDMA Send
is known as the receiver's inline threshold
<xref target="I-D.ietf-nfsv4-rfc5666bis"/>.
</t>
<t>
When marshaling an RPC transaction, a requester allocates and registers
a Reply chunk whenever the estimated maximum possible size of an RPC Reply
is larger than the requester's receive inline threshold.
A responder places the RPC Reply message
in the memory associated with the Reply chunk.
</t>

<section title="Reply Chunk Overrun">

<t>
If a responder overruns a Reply chunk during an RDMA Write,
a memory protection error occurs.
This typically results in connection loss.
Any RPC transactions running on that connection must be retransmitted.
The failing RPC transaction will never get a reply,
and it may result in additional connection loss events.
</t>
<t>
A smart responder can compare the size of an RPC Reply with the size
of a Reply chunk before starting to write the chunk.
However, there is no mechanism in RPC-over-RDMA Version One
to report that a reply cannot be sent.
The requester is likely to time out that RPC transaction and retransmit it,
but it will never get a reply.
</t>

</section>

<section title="Reply Size Estimation">

<t>
To decide whether a Reply chunk is needed,
requesters must estimate the maximum size of the RPC Reply
message expected for each transaction.
Upper Layer Bindings,
such as <xref target="I-D.ietf-nfsv4-rfc5667bis"/>,
provide implementation guidance on
how to perform this estimation and
in what cases the Upper Layer Protocol might have difficulty
giving an exact upper bound.
</t>
<t>
Unfortunately, there are rare cases where
such an upper bound cannot be estimated.
For instance, there is no way to know how large
an NFS Access Control List (ACL) is
until it is retrieved from an NFS server
<xref target="RFC5661"/>.
There is no protocol-specified limit on the size of NFS ACLs.
When retrieving an NFS ACL, there is always a risk, albeit a small one,
that the NFS client has not provided a large enough Reply chunk,
and that therefore the NFS server will not be able to return
that ACL to the client.
</t>

</section>

<section title="Requester Registration Costs">

<t>
For an Upper Layer Protocol like NFS version 4.2 <xref target="RFC7862"/>,
NFS COMPOUND Call and Reply messages can be large.
For instance, an NFSv4.2 COMPOUND can contain
a LOOKUP operation together with a GETATTR operation.
The size of a LOOKUP result is relatively small.
However, the GETATTR in that COMPOUND may request attributes that
are arbitrarily large
(such as NFS ACLs or security labels)
and whose size is not known in advance.
</t>
<t>
Thus a requester is responsible for provisioning quite a large reply
buffer for each LOOKUP COMPOUND, which can be a frequent request.
If the maximum possible reply message can be large,
the requester must provide a Reply chunk.
Most of the time, the actual size of a LOOKUP COMPOUND reply
is small enough to be sent using one RDMA Send.
</t>
<t>
In other words,
an NFS version 4 client provides a Reply chunk quite frequently
during RPC transactions,
but NFS version 4 servers almost never need to use it
because the actual size of replies is typically less than the inline threshold.
The overhead of allocating, registering, and invalidating this
chunk is significant,
and is unnecessary whenever the size of an actual RPC reply is small.
</t>

</section>

<section title="Denial of Service">

<t>
When an RPC transaction is cancelled or aborted
(e.g. due to premature exit of an application process)
a requester must invalidate or set aside Write and Reply
chunks associated with that transaction.
</t>
<t>
This is because the transaction is still running on the responder.
The responder is still obligated to return the result
of that transaction (usually via RDMA Write).
If memory registered on behalf of that transaction is re-used,
the requester must protect that memory from server RDMA Writes
associated with previous transactions.
</t>
<t>
A malfunctioning application or a malicious user on
the requester can create a situation where RPCs are
continuously initiated and then aborted, resulting
in responder replies that repeatedly terminate the
underlying RPC-over-RDMA connection.
</t>
<t>
A rogue responder can purposely overrun a Reply chunk to
kill a connection.
</t>
<t>
Repeated connection loss can result in a Denial of Service.
</t>

</section>

</section>

<section title="Responder-Provided Read Chunks">

<t>
A potential mechanism for resolving these issues is suggested
in Section 3.4 of <xref target="RFC5666"/>:
<list style="empty">
<t>
In the absence of a server-provided read chunk list in the
reply, if the encoded reply overflows the posted receive buffer, the
RPC will fail with an RDMA transport error.
</t>
</list>
Rather than a requester providing a Reply chunk
for conveying an as-yet-unconstructed large reply,
a responder can expose a Read chunk containing
the actual Payload stream of the RPC Reply message.
If both peers support this mechanism,
a responder is free to employ it any time
requester-provided reply resources are not adequate.
</t>
<t>
When sending a large RPC Call message,
requesters already employ Read chunks.
There is no advance indication or limit on the size of any RPC Call message.
To achieve the same flexibility for RPC Replies,
Read chunks can be used in the reverse direction
(e.g., responder exposes memory, requester initiates RDMA Read).
</t>
<t>
This introduces an additional leg
to the RPC-over-RDMA transfer model defined in
<xref target="I-D.ietf-nfsv4-rfc5666bis"/>.
Let's call this transfer model Read-Write-Read.
</t>
<t>
The requester does not have to estimate a reply size maximum
or allocate and register a Reply chunk in many cases.
Without a requester-provided Reply chunk,
the responder sends each reply inline.
When the actual size of an RPC Reply message is larger than the
receiver's inline threshold,
the responder provides a Read chunk, and
the requester pulls the reply from the responder.
This results in no wasted activity on the requester,
and arbitrarily large RPC Replies can be received reliably.
</t>
<t>
RPC-over-RDMA Version One currently has no support
for responder-provided Read chunks,
though it did have this support in the past.
Adapting this deprecated mechanism for new RPC-over-RDMA transports
is straightforward.
</t>

<section title="Specification">

<t>
To convey an RPC Reply,
a responder MAY choose to send a Position-Zero Read chunk (PZRC)
containing one or more RDMA segments.
A PZRC in an RPC Reply contains an RPC Reply's Payload stream,
just as it does in an RPC Call.
PZRCs are always sent via an RPC-over-RDMA RDMA_NOMSG message.
PZRCs are fully defined in
<xref target="I-D.ietf-nfsv4-rfc5666bis"/>.
A responder MUST NOT send Read chunks with non-zero Position fields.
</t>
<t>
A responder MUST use a PZRC
when the actual size of the RPC Reply's Payload stream
exceeds all requester-provided reply resources;
that is, when the inline threshold and any provided Reply chunk
are both too small to accommodate the Payload stream of the reply.
</t>
<t>
Upon receipt of an RPC Reply containing a PZRC,
the requester pulls the reply's Payload stream from the responder.
After pulling is complete,
the requester MUST send an RDMA_DONE message
to indicate that the responder may invalidate the memory region
associated with the Read chunk.
</t>
<t>
When an RPC transaction is aborted on a requester,
the requester normally retires the transaction immediately,
and then forgets its XID.
If a requester receives a reply
bearing a PZRC and does not recognized the XID,
the requester MUST respond with RDMA_DONE.
</t>

</section>

<section title="Remote Invalidation">

<t>
Remote Invalidation can save the responder the need
to explicitly invalidate memory containing an RPC Reply message.
If Remote Invalidate support is not indicated by either peer,
RDMA_DONE messages MUST be transmitted using only Send.
If Remote Invalidation support is indicated by both peers,
RDMA_DONE messages MAY be transmitted using Send With Invalidate.
</t>
<t>
The rules for choosing the inv_handle for this operation depend
on the version of the transport protocol that is use.
If the transport protocol supports only Initiator's choice,
the requester is free to choose any R_key in that RPC.
Otherwise, the responder has already provided an R_key that
may be invalidated remotely.
</t>

</section>

</section>

<section title="Analysis">

<section title="Benefit-Cost Analysis">

<section title="Benefits">
<t>
Outside of situations where krb5i or krb5p are in use,
the vast majority of RPC Replies can be conveyed via RDMA Send.
No extra registration/invalidation cost is incurred when
a large RPC Reply message is possible but the actual reply
size is small.
</t>
<t>
The responder-provided Read chunk approach accommodates
arbitrarily large replies.
Requesters no longer need to estimate the maximum size
of RPC Reply messages,
except on occasions when a Reply chunk is preferred.
Therefore the reply size estimation section
of Upper Layer Bindings can be reduced or eliminated.
</t>
<t>
There is no longer a need to provide protocol elements to report
that an RPC Reply cannot be returned because the requester
did not provide a large enough Reply chunk.
Those cases are fully covered by the use
of a responder-provided Read chunk.
</t>
<t>
When an RPC is cancelled on the requester
(say, because the requesting application has been terminated),
and no Reply chunk is provided,
the requester is no longer responsible
for invalidating that RPC's Reply chunk.
When the responder sends the reply,
it provides a PZRC and does not use RDMA Write
to transmit the RPC Reply message.
The transport connection is preserved because
no memory protection violation can occur.
</t>

</section>

<section title="Costs">

<t>
Responder memory is registered and exposed to requesters when replying.
When a responder has properly allocated a Protection Domain for
each transport and uses appropriate R_key rotation techniques
(see <xref target="sec:security-considerations"/>),
the exposure is minimal.
</t>
<t>
Using a Read chunk for large replies introduces a round-trip penalty.
</t>
<t>
There are certain cases where a Reply chunk can be used to
avoid this penalty.
When a requester knows the maximum reply size and also
knows the actual reply will be larger than the inline threshold,
a Reply chunk is reliable and faster than a responder-provided Read chunk.
</t>
<t>
For example, when krb5i security is in use,
the size of the reply to a large NFS READ is easy to estimate.
In this scenario, NFS requests of this type could be frequent,
thus choosing the more efficient transfer mechanism is desirable.
</t>
<t>
In most other scenarios, however,
responder-initiated Read chunks would be used infrequently,
since large RPC replies are rare.
This would allow responders to send replies using only Send in most cases,
while the responder-provided Read chunk mechanism acts as a safety
net for those few replies that cannot by returned inline.
</t>
<t>
In fact, the round-trip penalty would be paid much less often than
the Reply chunk registration cost is paid today.
This penalty is reduced further as the inline threshold is increased
past the average size of the Upper Layer Protocol's RPC Replies.
</t>

</section>

</section>

<section title="Examples of Choosing a Reply Mechanism">

<section title="Requester Choices">

<t>
As an RPC Call is constructed,
a requester might choose among possible reply mechanisms
based on its estimation of the size of the reply.
<list style="hanging">
<t hangText="Responder-provided Read chunk">
<vspace/>
The requester knows the minimum size of the reply
is smaller than the inline threshold, but
the maximum size of the reply is larger than the inline threshold;
or the requester cannot estimate the maximum size of the reply.
The client does not provide a Reply chunk.
</t>
<t hangText="Reply chunk">
<vspace/>
The requester knows the minimum and maximum size of the reply
is larger than the inline threshold.
The requester provides a Reply chunk.
</t>
<t hangText="Send-only">
<vspace/>
The requester knows the maximum size of the reply
is smaller than the inline threshold.
The requester does not provide a Reply chunk.
</t>
</list>
</t>

</section>

<section title="Responder Choices">

<t>
After a responder has constructed an RPC Reply,
it might choose which reply mechanism to employ
based on the size of the Payload stream of the RPC Reply message.
<list style="hanging">
<t hangText="Responder-provided Read chunk">
<vspace/>
The Payload stream is larger than the inline threshold
and either no Reply chunk was provided
or the provided Reply chunk is too small.
The responder uses a responder-provided Read chunk.
</t>
<t hangText="Reply chunk">
<vspace/>
If a usable Reply chunk is available,
the responder uses the Reply chunk.
</t>
<t hangText="Send-only">
<vspace/>
If no Reply chunk is available and
the Payload stream fits within the inline threshold,
the responder uses only Send or Send With Invalidate.
</t>
</list>
</t>

</section>

</section>

<section title="Alternate Mechanisms">

<t>
Increasing the inline threshold reduces the likelihood
of needing a Reply chunk, but
does not eliminate the risks associated
with unpredictably large replies.
</t>
<t>
Message Continuation
is more efficient than an explicit RDMA operation,
and does not require the exposure of requester or responder memory
<xref target="I-D.dnoveck-nfsv4-rpcrdma-rtrext"/>.
</t>
<t>
However, Message Continuation does limit the maximum size
of a conveyed message.
As with large inline thresholds,
without responder-provided Read chunks,
reply size estimation is still required to determine
when a Reply chunk is required, and
therefore there is still risk associated
with unpredictably large replies.
</t>

</section>

</section>

<section
 title="Security Considerations"
 anchor="sec:security-considerations">

<t>
The less frequent use of RDMA Write reduces opportunities
for memory overrun on the requester, and
reduces the risk of connection loss
after an application is terminated prematurely.
This helps reduce exposure
to accidental or malicious Denial of Service attacks.
</t>
<t>
Recommendations about adequate R_key rotation
and the appropriate use of Protection Domains can be found in
Section 8.1 of
<xref target="I-D.ietf-nfsv4-rfc5666bis"/>.
These recommendations apply when responders expose memory
to convey the Payload stream of an RPC Reply message.
</t>
<t>
Otherwise, this mechanism does not alter the security
profile of the transport protocol that employs it.
</t>

</section>

<section
 title="IANA Considerations"
 anchor="sec:iana-considerations">

<t>
There are no IANA Considerations.
</t>

</section>

</middle>

<back>

<references title="Normative References">

<?rfc include="references/reference.I-D.draft-ietf-nfsv4-rfc5666bis-10.xml"?>
<?rfc include="references/reference.RFC.2119.xml"?>

</references>

<references title="Informative References">

<?rfc include="references/reference.I-D.draft-dnoveck-nfsv4-rpcrdma-rtrext-01.xml"?>
<?rfc include="references/reference.I-D.draft-ietf-nfsv4-rfc5667bis-06.xml"?>
<?rfc include="references/reference.RFC.5661.xml"?>
<?rfc include="references/reference.RFC.5666.xml"?>
<?rfc include="references/reference.RFC.7862.xml"?>

</references>

<section title="Acknowledgments">

<t>
The author wishes to thank
Bill Baker and Greg Marsden for their support of this work.
</t>
<t>
Special thanks go to
Transport Area Director Spencer Dawkins,
nfsv4 Working Group Chair Spencer Shepler,
and
nfsv4 Working Group Secretary Thomas Haynes
for their support.
</t>

</section>

</back>

</rfc>
